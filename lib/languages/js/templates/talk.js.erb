<%= autogenerated_warning %>
/*********************************************************************************
 * TalkObject 
 * 
 * This module defines the constructor and methods for accessing TalkObjects  
 */

"use strict";

/**
 * TalkObject - variable definition
 * 
 * Takes an object and if found loads object
 */

var TalkObject = function(obj)
{
  this.__definition = { __class: { type: "string" } };
  if(obj) this.loadFromObject(obj);
};

/**
 * TalkObject vars, et-al 
 */
TalkObject.glossaries = {};
TalkObject.shortglossaries = {};
TalkObject.enumerations = {};
TalkObject.shortenumerations = {};
TalkObject.allConstants = {};
TalkObject.validators = {};
TalkObject.protocols = {};
TalkObject.methods = {};
TalkObject.prototype.__class = "TalkObject";
TalkObject.classes = { "TalkObject":TalkObject };
TalkObject.shortclasses = { "TalkObject":TalkObject };

/**
 * TalkValidationError - Creates an error message on validation error
 */
TalkObject.TalkValidationError = function(message) 
{
    
    this.name = "TalkValidationError";
    this.message = message || "Error validating Talk object";
};

TalkObject.TalkValidationError.prototype = new Error();
TalkObject.TalkValidationError.prototype.constructor = TalkObject.TalkValidationError;
TalkObject.TalkValidationError.makeError = function(cls, key, param, msg) 
{
  var errString = "Invalid value " + cls.__class + "." + key + 
    (param ? ("=" + JSON.stringify(param) + ": ") : " - ") + msg;
  if((typeof logger != 'undefined') && logger) logger.debug(errString);
    return new TalkObject.TalkValidationError(errString);
};


/**
 * TalkImplementationError - Creates an error message on implementation error
 *    (which shouldn't happen in production code)
 */
TalkObject.TalkImplementationError = function(message) {
//#JSCOVERAGE_IF 0
  // We shouldn't have this happen in production.
  this.name = "TalkImplementationError";
  this.message = message || "Error validating Talk object";
//#JSCOVERAGE_ENDIF
};
  
TalkObject.TalkImplementationError.prototype= new Error();
TalkObject.TalkImplementationError.prototype.constructor = TalkObject.TalkImplementationError;
TalkObject.TalkImplementationError.makeError = function(cls, key, msg) 
{
//#JSCOVERAGE_IF 0
    // This should not happen in production.
    var errString = "Invalid server implementation of " + cls.__class + "."
                  + key + ": " + msg;
    if((typeof logger != 'undefined') && logger) logger.error(errString);
    return new TalkObject.TalkImplementationError(errString);
//#JSCOVERAGE_ENDIF
};
  
/**
 * __validateString - augment the TalkObject with validation of strings
 */
TalkObject.prototype.__validateString = function(key, param, unsigned, size) 
{
  var def = this.__definition[key];
  if(typeof(param) != 'string') { // Make sure it a string type
    throw TalkObject.TalkValidationError.makeError(
            this, key, param, "Expected to be a string");
    }
  
  // Check against pattern matching
  if(def.regex && !param.match(new RegExp(def.regex))) {
    throw TalkObject.TalkValidationError.makeError(
        this, key, param, "Expected to match pattern: " + def.regex);
    }
    
    // Check over our constraints if they exist
  if(def.constraints) {
    var found = false;
    for(var constraintIdx in def.constraints) 
    {
      var constraint = def.constraints[constraintIdx];
      var glossary = TalkObject.glossary(constraint);
      if(!glossary) {
            /* The constraint references a non-existent glossary. This is an issue
             ** in our Talk renderer. This shouldn't happen. */
//#JSCOVERAGE_IF 0
        var errMsg = "Constrains on undefined glossary " + constraint;
        throw TalkObject.TalkImplementationError.makeError( this, key, errMsg);
//#JSCOVERAGE_ENDIF
      }
        
      for(var i = 0; i < glossary.__values.length; i++) 
      {
        if(glossary.__values[i] == param) {
          found = true;
          break;
        }
      }
    }
      
    if(!found) {
      var errMsg = "Expected to be in at least one of glossaries "
                   + def.constraints.join(", ");
      throw TalkObject.TalkValidationError.makeError(this, key, param, errMsg);
    }
  }

  return param;
};


/**
 * __validateInteger - augment the TalkObject with validation of Integer
 */
TalkObject.prototype.__validateInteger = function(key, param, unsigned, size) 
{
  var range = {};
  var def = this.__definition[key];

  // Validate number
    if(typeof(param) == 'string')
    {
      if(param.match(new RegExp("^(0x)?[0-9]+$"))) param = parseInt(param);
    }

    if(typeof(param) != 'number') 
    {
      var errMsg = "Expected " + key + " to be a number";
      throw TalkObject.TalkValidationError.makeError(this, key, param, errMsg);
    }
    
    // compute the ranges for validation checking
    if(unsigned) 
    {
      range.min = 0;
      range.max = Math.pow(2, size);
    } else {
      range.min = -Math.pow(2, size-1);
      range.max = Math.pow(2, size-1)-1;
    }

    if(def.minValue !== undefined && def.minValue !== null) 
    {
      range.min = Math.max(def.minVlaue, range.min);
    }
    
    if(def.maxValue !== undefined && def.maxValue !== null) 
    {
      range.max = Math.min(def.maxValue, range.max);
    }

    // check for constraints
    if(def.constraints) {
      var found = false;
      for(var constraintIdx in def.constraints) 
      {
        var constraint = def.constraints[constraintIdx];
        var enumeration = TalkObject.enumeration(constraint);
        if(!enumeration) 
        {
//#JSCOVERAGE_IF 0
          /* The constraint references a non-existent enumeration. This is an
** issue in our Talk renderer. This shouldn't happen. */
          var errMsg = "Constrains on undefined enumeration " + constraint;
          throw TalkObject.TalkImplementationError.makeError(this, key, errMsg);
//#JSCOVERAGE_ENDIF
        }

        for(var i = 0; i < enumeration.__values.length; i++) 
        {
          if(enumeration.__values[i] == param) 
          {
            found = true;
            break;
          }
        }
      }
      
      if(!found) 
      {
        var errMsg = "Expected to be in " + def.constraints.join(", ");
        throw TalkObject.TalkValidationError.makeError(this, key, param, errMsg);
      }
    }

    if(param < range.min) 
    {
      throw TalkObject.TalkValidationError.makeError( this, key, param, "Expected >= " + range.min);
    }
    
    if(param > range.max) 
    {
      throw TalkObject.TalkValidationError.makeError(this, key, param, "Expected <= " + range.max);
    }
    
    if(param != Math.floor(param)) 
    {
      throw TalkObject.TalkValidationError.makeError( this, key, param, "Expected integer");
    }

    return param;
};

/**
 * __validateReal - augment the TalkObject with validation of Real
 */
TalkObject.prototype.__validateReal = function(key, param) 
{
  var def = this.__definition[key];
  if(typeof(param) == 'string')
  {
    if(param.match(new RegExp("^[0-9]+(\.[0-9]+)?$"))) param = parseFloat(param);
  }
  if(typeof(param) != 'number') return "Expected numeric value for " + key;
  if(def.minValue !== undefined && def.minValue !== null && param < def.minValue) 
  {
    throw TalkObject.TalkValidationError.makeError(this, key, param, "Expected >= " + def.minValue);
    }
    if(def.maxValue !== undefined && def.maxValue !== null && param > def.maxValue) 
    {
      throw TalkObject.TalkValidationError.makeError(this, key, param, "Expected <= " + def.maxValue);
    }
    
    return param;
};

/**
 * __validateBool - augment the TalkObject with validation of Boolean
 */
TalkObject.prototype.__validateBool = function(key, param) 
{
  if(typeof(param) != 'boolean' && typeof(param) != 'number') 
  {
    throw TalkObject.TalkValidationError.makeError(this, key, param, "Expected boolean");
  }
  return param;
};

/**
 * __validateObject - augment the TalkObject with validation of Object 
 */
TalkObject.prototype.__validateObject = function(key, param) 
{
    return param;
};

/**
 * __validateTalkObject - augment the TalkObject with validation of TalkObject 
 */
TalkObject.prototype.__validateTalkObject = function(key, param, type) 
{
  var talkClass;
  if(param && '__class' in param) 
  {
    talkClass = TalkObject.classNamed(param.__class);
    if(!TalkObject.isSubclass(param.__class, type)) 
    {
      throw TalkObject.TalkValidationError.makeError( this, key, param, 
          "Expected a subclass of " + type);
    }
    if(!talkClass) 
    {
      throw TalkObject.TalkValidationError.makeError( this, key, param,
          "Value has unknown class " + param.__class);
    }
  } else {
    talkClass = TalkObject.classNamed(type);
    if(!talkClass) 
    {
      throw TalkObject.TalkImplementationError.makeError( this, key, param, 
          "Implementation specifies " + "unknown class " + type);
    }
  }
    
  var instance = new talkClass(param);
  instance.loadFromObject(param);
    return instance;
};

/**
 * __validateTypeStack - augment the TalkObject with validation of TypeStack 
 */
TalkObject.prototype.__validateTypeStack = function(key, param, typeStack) 
{
  var def = this.__definition[key];
  var type = typeStack[typeStack.length-1];
  var isBase = typeStack.length == 1;
  typeStack = typeStack.slice(0, def.typeStack.length-1);
    
  if(param === undefined || param === null) {
    if(def.required && def.typeStack.length-1 == typeStack.length) 
    {
      throw TalkObject.TalkValidationError.makeError( this, key, param, "Field is required");
    }
      
    return param;
  }
    
    if(isBase) 
    {
      if(type == '[]' || type == '{}') 
      {
//#JSCOVERAGE_IF 0
        // Implementation has a bad type stack. This shouldn't happen.
      throw TalkObject.TalkImplementationError.makeError( this, key, 
          "Nonsense field definition; expected individual, got " + type);
//#JSCOVERAGE_ENDIF
      }
      
      var val;
      var intMatch = type.match(/^(u)?int([0-9]+)$/);
      
      if(intMatch) 
      {
        val = this.__validateInteger(key, param, intMatch[1] == 'u', intMatch[2]);
      } else if(type == 'string') {
        val = this.__validateString(key, param);
      } else if(type == 'real') {
        val = this.__validateReal(key, param);
      } else if(type == 'bool') {
        val = this.__validateBool(key, param);
      } else if(type == 'talkobject') {
        if(!param.__class) 
        {
          throw new TalkObject.TalkValidationError.makeError( this, key, param, 
              "Expected explicit class identification in generic field.");
        }
        val = this.__validateTalkObject(key, param, "TalkObject");
      } else if(TalkObject.classNamed(type)) {
        val = this.__validateTalkObject(key, param, type);
        if(val && !val.__class) 
        {
          val.__class = type;
        }
      } else if(type == 'object') {
        val = this.__validateObject(key, param);
      } else {
        throw TalkObject.TalkImplementationError.makeError( this, key, "Unrecognized type " + type);
      }
      
      return val;
    } else {
      // This must be a collection type, '[]' for array, '{}' for dict
      if(typeof(param) != 'object' || !('constructor' in param)) {
        throw TalkObject.TalkValidationError.makeError( this, key, param, 
            "Expected a " + type + " collection");
      }

      if(type == '[]') 
      {
        if(param.constructor != Array) return undefined;
        var validatedArray = [];
        for(var i = 0; i < param.length; i++) 
        {
          var v = this.__validateTypeStack(key, param[i], typeStack);
          if(v === undefined) 
          {
            return undefined;
          }
          validatedArray.push(v);
        }
        return validatedArray;
      } else if(type == '{}') {
        if(param.constructor != Object) return undefined;
        var validatedDict = {};
        for(var k in param) 
        {
          var v = this.__validateTypeStack(key, param[k], typeStack);
          if(v === undefined) return undefined;
          validatedDict[k] = v;
        }
        return validatedDict;
      } else {
//#JSCOVERAGE_IF 0
        // Implementation has a bad type stack. This shouldn't happen.
        throw TalkObject.TalkImplementationError.makeError( this, key, param, 
            "Nonsense definition; expected collection, got " + type);
//#JSCOVERAGE_ENDIF
      }
    }
};



/**
 * __validateParameter - augment the TalkObject with validation of Parameter 
 */
TalkObject.prototype.__validateParameter = function(key, param) 
{
  var def = this.__definition[key];
  if(!("typeStack" in def)) 
  {
//#JSCOVERAGE_IF 0
      throw TalkObject.TalkImplementationError.makeError( this, key, 
          "Nonsense field definition; expected typeStack");
//#JSCOVERAGE_ENDIF
  }
    
  return this.__validateTypeStack(key, param, def.typeStack);
};

/**
 * __validate - augment the TalkObject with validation
 */
TalkObject.prototype.__validate = function(throwError) {
    try {
      for(var key in this.__definition) 
      {
        this.__validateParameter(key, this[key]);
        if(TalkObject.validators[this.__class] &&
            TalkObject.validators[this.__class][key]) 
        {
          var err = TalkObject.validators[this.__class][key](this, key);
          if(err) 
          {
//#JSCOVERAGE_IF 0
            throw TalkObject.TalkImplementationError.makeError( this, key, param, err);
//#JSCOVERAGE_ENDIF
          }
        }
      }
      return true;
    } catch(err) {
      if(throwError) throw err;
      return false;
    }
};


/**
 * instantiate - simple instantiation function will make numbers 0, booleans false and all else null
 */
TalkObject.prototype.instantiate = function() {
    try {
      for(var def in this.__definition) 
      {
        if( "typeStack" in def ) 
      {
        var type = def.typeStack[def.typeStack.length-1];
        var isBase = def.typeStack.length == 1;
          var val;
            if(isBase) 
            {
              var intMatch = type.match(/^(u)?int([0-9]+)$/);
              
              if(intMatch) { val = 0; } 
              else if(type == 'real') { val = 0; } 
              else if(type == 'bool') { val = false; } 
              // else if(type == 'string') { val = null; } 
              else { val = null; } 
              return val;
            } else val = null;
            this[key]=val;
      }
      }
      return true;
    } catch(err) {
      return false;
    }
};


/**
 * loadFromObject - augment the TalkObject with loadFromObject which returns a validated object
 */
TalkObject.prototype.loadFromObject = function(obj, strict) 
{
  var validatedData = {};
  for(var key in obj) 
  {
    if(key == "__class" || key == "constructor") continue;
    if(!(key in this.__definition)) 
    {
      if(strict) 
      { 
        throw new TalkObject.TalkValidationError( this, key, obj[key],
          "Attempted to instantiate in strict mode with unsupported field");
      }
    } else {
      validatedData[key] = this.__validateParameter(key, obj[key], strict);
    }
  }

  for(var key in validatedData) 
  {
    this[key] = validatedData[key];
  }
        
  // Run the validation check to make sure required fields are set.
  this.__validate(true);
  var keys = [];
  for(var k in this) 
  {
    keys.push(k + " (" + typeof(this[k]) + ")");
  }
    
    /* If we got __class from the prototype, it won't automatically show in
** JSON.stringify. This statement seems to be a no-op, but it actually
** fixes that issue. */
  this["__class"] = this.__class;
    
  return this;
};

/**
 * set - a javascript setter for a value in the object 
 */
TalkObject.prototype.set = function(key, value) 
{
  if(value === undefined && typeof(key) == "object") 
  {
    // Alternative usage; caller supplies key-value pairs to set.
    for(var k in key) 
    {
      if(!this.set(k, key[k])) return false;
    }
  }

  this[key] = this.__validateParameter(key, value, true);
  return true;
};

/**
 * get - a javascript getter for a value in the object 
 */
TalkObject.prototype.get = function(key) 
{
  if(!(key in this.__definition)) 
  {
    throw TalkObject.TalkValidationError.makeError(
              this, key, null, "not a valid field");
  }
  return this[key] ? this[key] : null;
};


/**
 * __objectify - not really sure what this does it looks like a deep copy
 */
TalkObject.prototype.__objectify = function(impliedClass) 
{
  for(var key in this) 
  {
    if(key.match(/^__/)) 
    {
      // Anything that starts with __ is internal use only; disregard it.
      continue;
    } else if(this[key] === null || this[key] === undefined) {
      // null values pass through.
      obj[key] = null;
    } else if(typeof(this[key]) == 'function'){
      // Objectifying functions makes no sense, so don't do that!
      continue;
    } else if(typeof(this[key]) == 'object' && "__objectify" in this[key]) {
      // Talk objects need to have recursive objectification
      var def = this.__definition[key];
      obj[key] = this[key].__objectify(def.type);
    } else {
      // Primitives can be assigned directly.
      obj[key] = this[key];
    }
  }

  if(TalkObject.shortName(impliedClass) != TalkObject.shortName(this.__class)) 
  {
    obj.__class = this.__class;
  }

  return obj;
};
  
/**
 * shortName - returns short name of object
 */
TalkObject.shortName = function(className) 
{
  var comps = className.split(".");
  var s = comps[comps.length-1];
  return s;
};

/**
 * shortName - returns the class object for a name. If not strict will look for shortnames
 *    as well as canonical
 */
TalkObject.classNamed = function(className, strict) 
{
  if(TalkObject.classes[className]) return TalkObject.classes[className];
  if(strict) return undefined;
  return TalkObject.shortclasses[className];
};

/**
 * addClass - This is what the talk generator created javascript calls for each generated class
 */
TalkObject.addClass = function(className, definition, superclassName) 
{
  if(!superclassName) superclassName = "TalkObject";
  var superclass = TalkObject.classNamed(superclassName);
  if(!superclass) 
  {
//#JSCOVERAGE_IF 0
      if((typeof logger != 'undefined') && logger) logger.error("Implementation error: No superclass '"
                  + superclassName + "' for class '" + className + "'");
      return undefined;
//#JSCOVERAGE_ENDIF
  }

  var cls = function(obj) 
  {
    if(obj) this.loadFromObject(obj);
    else this.instantiate();
  };

    cls.prototype = new superclass();
    cls.prototype.constructor = cls;
    cls.prototype.__super = superclass;
    cls.prototype.__class = className;
    cls.prototype.__definition = {};

    for(var k in superclass.prototype.__definition) {
      cls.prototype.__definition[k] = superclass.prototype.__definition[k];
    }

    for(var k in definition) 
    {
      cls.prototype.__definition[k] = definition[k];
    }

    TalkObject.classes[className] = cls;
    TalkObject.shortclasses[TalkObject.shortName(className)] = cls;

    return cls;
};
  
/**
 * setValidator - Setup a validator on a fieldname
 */
TalkObject.setValidator = function(className, fieldName, validator) 
{
  var cls = TalkObject.classNamed(className);
  if(!(cls.prototype.__class in TalkObject.validators)) 
  {
    TalkObject.validators[cls.prototype.__class] = {};
  }
    
  TalkObject.validators[cls.prototype.__class][fieldName] = validator;
};

/**
 * instance - get an instance of a className from obj
 */
TalkObject.instance = function(className, obj, strict, throwError) 
{
  var cls = TalkObject.classNamed(className, strict);
  if(!cls) 
  {
//#JSCOVERAGE_IF 0
      if((typeof logger != 'undefined') && logger) logger.trace("Cannot create instance of unknown class " + className
                 + " (strict = " + (strict ? "yes" : "no") + ")");
      return undefined;
//#JSCOVERAGE_ENDIF
  }
    
  try {
    var instance = new cls(obj);
    return instance;
  } catch(err) {
    if(throwError) throw err;
    return undefined;
  }
};
  
/**
 * isSubclass - returns true if subclassName is subclass of superclassName
 */
TalkObject.isSubclass = function(subclassName, superclassName) 
{
    var c = TalkObject.classNamed(subclassName);
    var s = TalkObject.classNamed(superclassName);
    while(c && c != s) 
    {
      c = c.prototype.__super;
    }

    return c != undefined;
};

/**
 * glossary - returns a glossary lookup
 */
TalkObject.glossary = function(glossaryName, strict) 
{
  var r=undefined;
  if(TalkObject.glossaries[glossaryName]) {
    r = TalkObject.glossaries[glossaryName];
  } else if(strict) {
    r = undefined;
  } else if(TalkObject.shortglossaries[glossaryName]) {
    r = TalkObject.shortglossaries[glossaryName];
  }

  if(!r) 
  {
//#JSCOVERAGE_IF 0
    if((typeof logger != 'undefined') && logger) logger.error("Undefined glossary: " + glossaryName + " (strict: "
                 + (strict ? "yes" : "no") + ")");
//#JSCOVERAGE_ENDIF
  }
    
  return r;
};

/**
 * enumeration - returns an enumeration lookup
 */
TalkObject.enumeration = function(enumeration, strict) 
{
    var r = undefined;
    if(TalkObject.enumerations[enumeration]) {
      r = TalkObject.enumerations[enumeration];
    } else if(strict) {
      r = undefined;
    } else if(TalkObject.shortenumerations[enumeration]) {
      r = TalkObject.shortenumerations[enumeration];
    }

    if(!r) 
    {
//#JSCOVERAGE_IF 0
      if((typeof logger != 'undefined') && logger) logger.error("Undefined enumeration: " + enumeration + " (strict: "
                  + (strict ? "yes" : "no") + ")");
//#JSCOVERAGE_ENDIF
    }
    return r;
};

/**
 * constantFromSource - generic function which can be called for eitehr glossary or enumeration
 *    epending on the parameters passed in
 */
TalkObject.constantFromSource = function(container, constant, source, strict) 
{
  var r;
  r = source(container, strict);
  if(!r) r = source(container, strict);
  if(!r) return undefined;
  return r[constant];
};

/**
 * constant - return a constant looking in both glossary and enumerations
 */
TalkObject.constant = function(container, constant, strict) 
{
  var r = undefined;
  if(constant == undefined) 
  {
    r = TalkObject.allConstants[container];
    } else {
      r = TalkObject.constantFromSource(container, constant, TalkObject.glossary, strict)
      || TalkObject.constantFromSource(container, constant, TalkObject.enumeration, strict);
    }

    if(r === undefined) 
    {
      var constantName = container;
      var caller = callerid();
      if(constant) constantName += "."+constant;
      if((typeof logger != 'undefined') && logger) logger.error("Undefined constant: " + constantName + " (strict: "
             + (strict ? "yes" : "no") + ", " + caller.shortFile + ":" + caller.line + ")");
    }
    
    return r;
};

/**
 * protocol - return a protocol object 
 */
TalkObject.protocol = function(protocol) 
{
  return TalkObject.protocols[protocol];
};


/**
 * addGlossary - This is what the talk generator created javascript calls for each generated glossary
 */
TalkObject.addGlossary = function(glossaryName, glossary) 
{
  var newGloss = { '__values':[] };
  for(var k in glossary) 
  {
    var v = glossary[k];
    newGloss.__values.push(v);
    newGloss[k] = v;
    TalkObject.allConstants[k] = v;
  }

  TalkObject.glossaries[glossaryName] = newGloss;
  TalkObject.shortglossaries[TalkObject.shortName(glossaryName)] = newGloss;
  return newGloss;
};

/**
 * addEnumeration - This is what the talk generator created javascript calls for each generated enumeration
 */
TalkObject.addEnumeration = function(enumerationName, enumeration) 
{
  var newEnum = { '__values':[] };
  for(var k in enumeration) 
  {
    var v = enumeration[k];
    newEnum.__values.push(v);
    newEnum[k] = v;
    TalkObject.allConstants[k] = v;
  }

  var shortName = TalkObject.shortName(enumerationName);
  TalkObject.enumerations[enumerationName] = newEnum;
    TalkObject.shortenumerations[shortName] = newEnum;
    return newEnum;
};

/**
 * addProtocol - This is what the talk generator created javascript calls for each generated protocol
 */
TalkObject.addProtocol = function(protocolName, protocol) 
{
  for(var method in protocol )
    TalkObject.methods[protocolName + "." + method] = method;
  TalkObject.protocols[protocolName] = protocol;
};

TalkObject.method = function(protocolName, method) 
{
  var key = protocolName + "." + method;
  if( key in TalkObject.methods ) return TalkObject.methods[key];
  
};

<%= (@base[:class].map { |cls| class_line(cls) rescue nil }).compact.join("\n") %>
<%= (@base[:protocol].map { |proto| protocol_line(proto) rescue nil }).compact.join("\n") %>
<%= (@base[:glossary].map { |glossary| glossary_line(glossary) rescue nil }).compact.join("\n") %>
<%= (@base[:enumeration].map { |enumeration| enumeration_line(enumeration) rescue nil }).compact.join("\n") %>
