

@base[:class].each do |cls|
    @current_class = cls
    @current_class[:field] ||= []
    file_base = filename_for_class(cls)
     generate_template(file_base+".swift", "class.swift".erb)
  end

def autogenerated_warning
  <<-AUTOGEN_DONE
// Autogenerated from Talk
// Please do not edit this file directly. Instead, modify the underlying .talk files.
  AUTOGEN_DONE
end

def field_variable(field)
  lines = []
  lines.push comment_block(field, 1)
  lines.push "\tvar #{field[:name]}:#{field_datatype(field)} = #{field_datatype(field)}()"
  lines.join("\n")
end

def field_datatype(field)
  field_datatype_rec(field, field[:type])
end

def field_datatype_rec(field, type)
  return field_datatype_basic(field, type.last) if type.length == 1
  t = type.last

  r = field_datatype_rec(field, type[0 .. -2])
  if is_array? t then
    "Array<#{r}>"
  elsif is_dict? t then
    "Dictionary<String, #{convert_field_for_map(r)}>()"
  else
    nil
  end
end

def field_datatype_basic(field, type)
  if is_primitive? type then
    case type
    when "string"
      "String"
    when "real"
      "Double"
    when "bool"
      "Bool"
    when "talkobject"
      rootclass
    when "int8"
      "Int"
    when "uint8"
      "Int"
    when "int16"
      "Int"
    when "uint16"
      "Int"
    when "int32"
      "Int"
    when "uint32"
      "Int"
    when "int64"
      "Int"
    when "uint64"
      "Int"
    end
  else
    truncated_name type
  end
end

def convert_field_for_map(field)
  case field
  when "byte"
    "UInt8"
  when "short"
    "Short"
  when "int"
    "Int"
  when "long"
    "Int"
  when "double"
    "Double"
  when "string"
    "String"
  else
    field
  end
end


def constant_definition(constant)
  "case #{constant[:name]} = #{constant[:value].to_i}"
end

def glossary_docuementation_block(glossary, indent_level=0)
  lines = []
  indent = "\t" * indent_level
  lines.push(indent + "/**")
  lines.push(wrap_text_to_width(glossary[:description], 80, indent + " *  ")) unless glossary[:description].nil?
  lines.push(indent + "  ")
  lines.push(indent + (glossary[:term].map { |term| " - "+ term[:name]+":"+ term[:description].nil? ? "" : {term[:description]} }).join("\n"))
  lines.push(indent + " */")

  lines.join("\n")
end

def enumeration_docuementation_block(enumeration, indent_level=0)
  lines = []
  indent = "\t" * indent_level
  lines.push(indent + "/**")
  lines.push(wrap_text_to_width(enumeration[:description], 80, indent + " *  ")) unless enumeration[:description].nil?
  lines.push(indent + "  ")
  lines.push(indent + (enumeration[:constant].map { |constant| " - "+ constant[:name]+":"+ constant[:description].nil? ? "" : {constant[:description]} }).join("\n"))
  lines.push(indent + " */")

  lines.join("\n")
end

def protocol_constant_name(name)
  name = (name.split("/").map { |x| x[0].upcase + x[1..-1] }).join("")
end

def protocol_documentation_block(protocol, indent_level=0)
  lines = []
  indent = "\t" * indent_level
  lines.push(indent + "/**")
  lines.push(wrap_text_to_width(protocol[:description], 80, indent + " *  ")) unless protocol[:description].nil?
  lines.push(indent + "  ")
  lines.push(indent + (protocol[:method].map { |method| " - "+ method[:name]+":"+ method[:description].nil? ? "" : {method[:description]} }).join("\n"))
  lines.push(indent + " */")

  lines.join("\n")
end
