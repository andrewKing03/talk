require 'set'

def make_source
  types = [ :class, :enumeration, :glossary]
  types.each do |type|
    @base[type].each do |current|
      @current = current
      @current[:field] ||= [] if type == :class
      generate_template(filename_for_entity(@current), type.to_s+".java.erb")
    end
  end
end

def filename_for_entity(name)
  name = name[:name] if name.is_a? Hash
  name.gsub(".", "/") + ".java"
end

def autogenerated_warning
  <<-AUTOGEN_DONE
/* Autogenerated from Talk
** Please do not edit this file directly. Instead, modify the underlying .talk files. */
  AUTOGEN_DONE
end

def definition_reference(tag)
  "@talkFile #{tag[:__meta][:file]}:#{tag[:__meta][:line]}"
end

def rootclass
  @target[:rootclass] || "io.usetalk.TalkObject"
end

def superclass(cls)
  cls[:inherits] || rootclass
end

def class_package(cls)
  cls[:name].split(".")[0..-2].join(".")
end

def list_references_for_class(cls)
  references = Set.new
  cls[:field].each do |field|
    unless is_primitive?(field[:type].first) then
      references.add(field[:type])
    end
  end

  references.to_a
end

def import_classes
  (list_references_for_class(@current).map { |name| "import #{name};"}).join("\n")
end

def comment_block(tag, indent_level=0)
  lines = []
  indent = "\t" * indent_level
  lines.push(indent + "/*!")
  lines.push(wrap_text_to_width(tag[:description], 80, indent + " *  ")) unless tag[:description].nil?
  lines.push(indent + " *  ")
  lines.push(indent + " *  " + definition_reference(tag))
  lines.push(indent + " */")

  lines.join("\n")
end

def detail_comment_block(cls)
  lines = []
  lines.push("\t/**")
  lines.push("\t *  #{truncated_name cls[:name]}")
  cls[:field].each { |f| lines.push("\t *  @param #{field_datatype f} #{f[:name]}") }
  lines.join("\n")
end

def field_datatype_rec(field, stack)
  return field_datatype_basic(field, stack.last) if stack.length == 1
  t = stack.last

  r = field_datatype_rec(field, stack[0 .. -2])
  if is_array? t then
    "[]"
  elsif is_dict? t then
    "Map<String, #{r}>"
  else
    nil
  end
end

def field_datatype_basic(field, type)
  if is_primitive? type then
    case type
    when "string"
      "String"
    when "real"
      "double"
    when "bool"
      "boolean"
    when "object"
      "Object"
    when "talkobject"
      "TalkObject"
    else
      size = integer_size(type)
      size *= 2 if is_unsigned? type # java has no unsigned type; just use the next size up
      case 
      when 8
        "byte"
      when 16
        "short"
      when 32
        "int"
      when 64
        "long"
      when 128
        "BigDecimal"
      end
    end
  else
    truncated_name type
  end
end

def field_datatype(field)
  field_datatype_rec(field, field[:type])
end

def field_variable(field)
  lines = []
  lines.push comment_block(field, 1)
  lines.push "\tprotected #{field_datatype(field)} #{field[:name]};"
  lines.join("\n")
end

def field_accessors(field)
  lines.push wrap_text(field[:description], " *  ", 1)
  lines.push field[:deprecated] if field.has_key? :deprecated
  lines.push definition_reference(field)
  lines.push " * @param #{field[:name]} #{field[:description]}"
  lines.push "\tpublic void #{setter_name(field)}(#{field_datatype(field)} #{field[:name]}) {"
  lines.push "\t\tthis.#{field[:name]} = #{field[:name]}"
  lines.push "\t}"
  lines.join "\n"
end
