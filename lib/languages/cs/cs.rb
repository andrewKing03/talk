require 'set'

def make_source
  types = [ :class, :enumeration, :glossary]
  types.each do |type|
    @base[type].each do |current|
      @current = current
      @current[:field] ||= [] if type == :class
      generate_template(filename_for_entity(@current), type.to_s+".cs.erb")
    end
  end
  @base[:protocol].each do |current|
    @current = current
    generate_template("com/acres4/common/protocol/#{current[:name]}.cs", "TalkProtocol.cs.erb")
  end
end

def filename_for_entity(name)
  name = name[:name] if name.is_a? Hash
  name.gsub(".", "/") + ".cs"
end

def autogenerated_warning
  <<-AUTOGEN_DONE
/* Autogenerated from Talk
** Please do not edit this file directly. Instead, modify the underlying .talk files. */
  AUTOGEN_DONE
end

def definition_reference(tag)
  "@talkFile #{tag[:__meta][:file]}:#{tag[:__meta][:line]}"
end

def rootclass
  @target[:rootclass] || "io.usetalk.TalkObject"
end

def superclass(cls)
  cls[:inherits] || rootclass
end

def class_package(cls)
  cls[:name].split(".")[0..-2].join(".")
end

def list_references_for_class(cls)
  references = Set.new
  cls[:field].each do |field|
    unless is_primitive?(field[:type].first) then
      references.add( class_package( class_named(field[:type][0], @base[:class]) ))
    end
  end

  references.add("System.Collections.Generic") if class_has_map(cls)
  references.to_a
end

def class_has_map(cls)
  cls[:field].each do |f|
    return true if f[:type].include? "{}"
  end

  false
end

def import_classes
  (list_references_for_class(@current).map { |name| "using #{name};"}).join("\n")
end

def comment_block(tag, indent_level=0)
  lines = []
  indent = "\t" * indent_level
  lines.push(indent)
  lines.push(indent + "/**")
  lines.push(wrap_text_to_width(tag[:description], 80, indent + " *  ")) unless tag[:description].nil?
  lines.push(indent + " *  ")
  lines.push(indent + " *  " + definition_reference(tag))
  lines.push(indent + " */")

  lines.join("\n")
end

def field_datatype_rec(field, stack)
  return field_datatype_basic(field, stack.last) if stack.length == 1
  t = stack.last

  r = field_datatype_rec(field, stack[0 .. -2])
  if is_array? t then
    "#{r}[]"
  elsif is_dict? t then
    "Dictionary<string, #{convert_field_for_map(r)}>"
  else
    nil
  end
end

def convert_field_for_map(field)
  case field
  when "byte"
    "byte"
  when "short"
    "short"
  when "int"
    "int"
  when "long"
    "long"
  when "double"
    "double"
  else
    field
  end
end

def field_datatype_basic(field, type)
  if is_primitive? type then
    case type
    when "string"
      "string"
    when "real"
      "double"
    when "bool"
      "bool"
    when "object"
      "object"
    when "talkobject"
      rootclass
    when "int8"
      "sbyte"
    when "uint8"
      "byte"
    when "int16"
      "short"
    when "uint16"
      "ushort"
    when "int32"
      "int"
    when "uint32"
      "uint"
    when "int64"
      "long"
    when "uint64"
      "ulong"
    end
  else
    truncated_name type
  end
end

def field_datatype(field)
  field_datatype_rec(field, field[:type])
end

def field_variable(cls,field)
  lines = []
  lines.push comment_block(field, 2)
  lines.push "\t\tpublic #{field_datatype(field)} #{mapped_name(cls, field, :field)} { get; set; }"
  lines.join("\n")
end

def setter_name(field)
  "set#{field[:name].sub(/^(\w)/) {|s| s.capitalize}}"
end

def getter_name(field)
  "get#{field[:name].sub(/^(\w)/) {|s| s.capitalize}}"
end

def field_accessors(cls, field)
  lines = []
  lines.push "\t\t/**"
  lines.push "\t\t#{wrap_text_to_width(field[:description])}"
  lines.push "\t\t#{field[:deprecated] if field.has_key? :deprecated}"
  lines.push "\t\t#{definition_reference(field)}"
  lines.push "\t\t@param #{field[:name]} #{field[:description]}"
  lines.push "\t\t*/"
  lines.push "\t\tpublic void #{setter_name(field)}(#{field_datatype(field)} #{mapped_name(cls, field,:field)}) {"
  lines.push "\t\t\tthis.#{mapped_name(cls, field, :field)} = #{mapped_name(cls, field, :field)};"
  lines.push "\t\t}"
  lines.push "\t\tpublic #{field_datatype(field)} #{getter_name(field)}() {"
  lines.push "\t\t\treturn this.#{mapped_name(cls, field, :field)};"
  lines.push "\t\t}"
  lines.join "\n"
end
