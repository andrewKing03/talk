def make_source
  @prefix = common_class_prefix if meta(:namespace) == "true"
  master_files = [ "TalkClasses.h", "TalkClassesForward.h", "TalkConstants.h", "TalkObjectList.h", "TalkDefinition+Autogenerated.m" ]
  master_files.each { |template| generate_template(template) }

  @base[:class].each do |cls|
    @current_class = cls
    @current_class[:field] ||= []
    file_base = filename_for_class(cls)
    [".h", ".m"].each { |ext| generate_template(file_base+ext, "class"+ext+".erb") }
  end
end

def filename_for_class(cls)
  class_dir = "classes"
  if meta(:namespace) == "true" then
    namespace = cls[:name][@prefix.length..-1].split(".")[0..-2]
    return File.join(class_dir, truncated_name(cls)) if namespace.empty?

    namespace = namespace[1..-1] while namespace[0].length == 0
    File.join(class_dir, namespace.join("/"), truncated_name(cls))
  else
    File.join(class_dir, truncated_name(cls))
  end
end

def autogenerated_warning
  <<-AUTOGEN_DONE
// Autogenerated from Talk
// Please do not edit this file directly. Instead, modify the underlying .talk files.
  AUTOGEN_DONE
end

def glossary_term_name(name)
  "k"+name
end

def constant_definition(constant)
  "#{constant[:name]} = #{constant[:value].to_i}, #{comment_line(constant)}"
end

def comment_line(tag)
  tag[:description].nil? ? "" : "//!< #{tag[:description]}"
end

def comment_block(tag, indent_level=0)
  lines = []
  indent = "\t" * indent_level
  lines.push(indent + "/*!")
  lines.push(wrap_text_to_width(tag[:description], 80, indent + " *  ")) unless tag[:description].nil?
  lines.push(indent + " *  ")
  lines.push(indent + " *  " + definition_reference(tag))
  lines.push(indent + " */")

  lines.join("\n")
end

def definition_reference(tag)
  "@talkFile #{tag[:__meta][:file]}:#{tag[:__meta][:line]}"
end

def assist_line(field)
  return nil if field[:type].length <= 1
  elements = []
  field[:type].reverse.each do |type|
    elements.push case
      when is_array?(type)
        "array"
      when is_dict?(type)
        "dict"
      when type == "talkobject"
        "TalkObject"
      when is_native?(type)
        "native"
      else
        truncated_name(type)
    end
  end

  stringified = elements.map { |e| "@\"#{e}\"" }
  "@[#{stringified.join(",")}]"
end

def protocol_constant_name(name)
  name = name.gsub("/","")
  name[0].upcase + name[1..-1]
  "kProto#{name}"
end

def protocol_method_name(p_name, m_name)
  m_name = m_name[0].upcase + m_name[1..-1]
  "kProto#{protocol_constant_name(p_name)}Method#{m_name}"
end

def class_field_maps(cls)
  @target[:map].select { |map| map[:class_name] == truncated_name(cls[:name]) }
end

def trimmed_fields(cls)
  return cls[:field] unless truncated_name(cls[:name]) == 'NamedObjectWrapper'
  cls[:field].reject { |f| f[:name] == "body" }
end

def dynamic_body_for_named_wrapper
  return "@dynamic body;" if truncated_name(@current_class[:name]) == 'NamedObjectWrapper'
  ""
end

def primitive_type(unsigned, size)
  type = "int#{size}_t"
  type = "u" + type if unsigned
  type
end

def field_tags(field)
  case field[:type].last
  when "real", "bool", "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64"
    "(readwrite,assign)"
  else
    "(readwrite,nonatomic,retain)"
  end
end

def field_definition(cls, field)
  base_type = field[:type].last
  objc_type = case
    when is_array?(base_type)
      "NSMutableArray *"
    when is_dict?(base_type)
      "NSMutableDictionary *"
    when (base_type == "talkobject" or base_type == "object")
      "TalkObject *"
    when base_type.match(/(u)?int(8|16|32|64)/)
      primitive_type(not($1.nil?), $2)
    when base_type == "real"
      "double"
    when base_type == "bool"
      "BOOL"
    when base_type == "string"
      "NSString *"
    else
      truncated_name(base_type) + " *"
  end
  "#{objc_type} #{mapped_name(cls, field, :field)}"
end
