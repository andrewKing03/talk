def make_source
  prefix = common_class_prefix if meta(:namespace) == "true"
  master_files = [ "TalkClasses.h", "TalkClassesForward.h", "TalkConstants.h", "TalkObjectList.h "]
  master_files.each { |template| generate_template(template) }

  @base[:class].each do |cls|
    @current_class = cls
    if meta(:namespace) == "true" then
      namespace = cls[:name][prefix.length..-1].split(".")
      namespace = namespace[1..-1] while namespace[0].length == 0
      file_base = File.join(namespace.join("/"), truncated_name(cls))
      [".h", ".m"].each do { |ext| generate_template(file_base+ext, "class"+ext) }
    end
  end
end

def autogenerated_warning
  <<-AUTOGEN_DONE
// Autogenerated from Talk
// Please do not edit this file directly. Instead, modify the underlying .talk files.
  AUTOGEN_DONE
end

def truncated_name(name)
  name = name[:name] if name.is_a? Hash
  name.split('.').last
end

def wrap_text_to_width(text, width=80, preamble="")
  width -= premable.length
  words = text.split(/\s+/)
  lines = [preamble]

  words.each do |word|
    if (lines.last + word).length >= width then
      lines.push preamble + word
    else
      lines.last << word
    end
  end

  lines.empty? ? "" : lines.join("\n")
end

def comment_block(tag, indent_level=0)
  lines = []
  indent = "\t" * indent_level
  lines.push(indent + "/*!")
  lines.push(wrap_text_to_width(text, 80, indent + " *  "))
  lines.push(indent + " *  " + definition_reference(tag))
  lines.push(" */")

  lines.join("\n")
end

def definition_reference(tag)
  "@talkFile #{tag[:file]}:#{tag[:line]}"
end

def superclass(cls)
  cls[:inherits].nil? ? "TalkObject" : cls[:inherits]
end

def is_native?(type)
  type != "talkobject" and is_primitive?(type)
end

def is_array?(type)
  type == "[]"
end

def is_dict?(type)
  type == "{}"
end

def mapped_name(container_name, object_name, type, name_key=:name)
  object_name = object_name[:name] if object_name.is_a? Hash
  container_name = container_name[:name] if container_name.is_a? Hash

  @target[:map].each do |map|
    matches = map[:type] == type.to_s and map[:class_name] == container_name and map[:field_name] == object_name
    return map[:new_field_name] if matches
  end

  object_name
end

def assist_line(field)
  return nil if field[:type].length <= 1
  elements = []
  field[:type].each do |type|
    elements.push case type
      when is_array?(type)
        "array"
      when is_dict?(type)
        "dict"
      when "talkobject"
        "TalkObject"
      when is_native?(type)
        "native"
      else
        raise "Unknown container type '#{type}' in #{field[:type].reverse.join('')}"
    end
  end

  elements.join
end

def primitive_type(unsigned, size)
  type = "int#{size}_t"
  type = "u" + type if unsigned
  type
end

def field_definition(cls, field)
  objc_type = case field[:type].first
    when is_array?(type)
      "NSMutableArray *"
    when is_dict?(type)
      "NSMutableDictionary *"
    when "talkobject" or "object"
      "TalkObject *"
    when /(u)?int(8|16|32|64)/
      primitive_type(not $1.nil?, $2)
    when "real"
      "double"
    when "bool"
      "BOOL"
    when "string"
      "NSString *"
  "#{objc_type} #{mapped_name(cls, field, :field)}"
end
